
Rough draft of essential documentation...

Compiling commands
==================

f90 -c -dalign maths.f90
f90 -c -dalign visibility.f90
f90 -c -dalign fit.f90
f90 -c -dalign inout.f90
f90 -c -dalign plot.f90
f90 -o mfit main.f90 maths.o visibility.o fit.o inout.o plot.o -dalign 
	`pgplotlink` -lnag -lf77compat



Model file format
=================

Program reads through model file until it comes across the keyword 'source' at
the begining of a line. It then reads the next 2 words as the source name. 
There must be 2 words present like 'alp' 'Ori' etc.

Program then reads in the various components of the model. It runs through the
model file until it comes across the keyword "component" at the begining of the
line. It then reads the data for that particular component:
n.b. to disregard a component simply replace "component" with "!component" etc
- it will then be ignored as the keyword marking a component info block.

Component data must follow this prescription: keyword is present on the start
of the line followed by the values associated with it.

Maximum number of components is set to 10. 
Maximum order of taylor and gauss-hermite LD types is also set to 10.

keyword            parameter information
-------            ---------------------

name     	   a one word name for the component itself, e.g. 'main' or 
		   'hot_spot' or something.

shape_type         one word specifying the shape of the component can have 
		   eiter 'ellipse' 'disc' or 'point' obviously corresponding
		   to elliptical, circular or unresolved point objects.

ld_type            one word specifying limb darkening type of the component, 
	           'uniform', 'taylor', 'hestroffer', 'square-root', 
	           'gauss-hermite' or 'gaussian'. hankel transform functions 
		   all as defined in the maths work. if 'point' is specified 
	           as the shape_type then nothing should be put here.

ld_order           a single integer (1-10) specifying the order the limb 
		   darkening in the 'taylor' and 'gauss-hermite' LD cases.
                   nothing should be put in other cases.

position           two double precision numbers follow describing the position
                   of the component with respect to the chosen phase reference
                   point. this is only important for multiple component models
		   since for a single component position corresponds to simple 
		   phase factor.
	           first number is the polar radius r of the component in mas
                   second num is the polar angle theta in deg (measured N>E as
                   in citvlb stuff)

position_prior     two double precision numbers giving the prior widths for 
                   the position data above (prior assumed gaussian of standard
                   deviation = prior width)

flux               one double precision number giving the flux B of the source.
                   visibilties are always normalised so that unit visibility is
                   obtained on zero baselines therfore flux is a relative 
                   quantitity and has no meaning for a single component model.

flux_prior         one double precision number giving prior width on the flux

shape_param        up to three double precision numbers giving shape info.
                   if 'point' is the shape type nothing should be put here.
                   if 'disc' is the shape type only one number should be put,
                   the diameter, a, of the disc in mas. ("diameter" is defined 
                   slightly differenly depending on the limb darkening model,
                   e.g. it is FWHM for gaussian - see the maths stuff).
                   if 'ellipse' is the shape type all three numbers are needed
                   giving the major axis, a, in mas, the orientation, phi, of 
		   the major axis (measured N>E as in citvlb stuff) in degrees 
		   and the eccentricity factor epsilon

shape_param_prior  a prior for each of the numbers given above

ld_param           up to twenty limb darkening parameters should be put here
                   for 'uniform' 'prior' and 'gaussian' LD types nothing should
                   be here. 
		   for 'hestroffer' only one paramter, the hestroffer 
		   parameter "alpha" should be put. 
		   for 'square-root' only parameters - the "alpha" and "beta"
                   coefficients of (1-mu) and (1-root(mu)) should be put.
                   'gauss-hermite' and 'taylor' cases require the same number
                   of parameters as specified in the ld_order field above.

ld_param_prior     prior widths associated with each number supplied above.



Illegal minimisations
=====================

Fitting is made by attempting to minimise the negative logarithm of posterior
probability. Parameters with non-zero priors are considered to be free 
parameters in the fitting process. Fitting routine will trigger an error on 
the following "illegal" types of minimisation:

1. attempting to fit a one component model with position angle theta and/or
   position radius r as free parameter(s)
2. attempting to fit any components that have non-free position radius r 
   that is set to zero but have position angle theta as a free parameter 
   (if r is zero but free to be varied then this is okay)
3. attempting to fit a one component model with flux B as a free parameter
4. attempting to fit any elliptical components that have non-free eccentricity 
   set to unity but have orientation angle phi free to vary
5. any model with no free parameters(!)
6. attempting to fit non-centrosymmetric models to vis/nvis file types



Minimisation method
===================

The minimisation of negative log posterior is carried out by the Downhill 
Simplex Algorithm (Nelder & Mead, 1965, Computer Journal vol. 7 pp308-313) 
using code based on Numerical Recipies chapter 10.4 (pp 402-406). Details 
of the algorithm are not too important. 

The solution is a point in N-dimensional parameter space where N is the number
of free parameters. The solution is initially bracketed by a "simplex" 
conisisting of N+1 vertices in the space. The algorithm gradually reduces 
the volume of the simplex until it encloses the solution point to a sufficent 
tolerance (specified as a multiple of the machine precision in its 
implementation here - multiplying factor is the eta variable in fit.f90).

Upon convergence to the given tolerance the algorithm finishes. The simplex
point closest to the solution is taken to be the solution position. 
The positions of all the vertices are used to calculate minimum and maximum
values of the minima on all parameters. The rms deviation of the points away
from the solution point are used to provide a single estimate of the fit
accuracy (quoted as the "fit error" in main.f90).
For example consider 2-D parameter space for the parameters x and y. Imagine
the final (3-point) simplex has reached tolerance at the vertices:
[0.9,1.8] [1.0,1.7] and [1.1,2.2] 
Which have neg log posteriors of 11, 10 and 13. 
The [1.0,1.7] vertex has the lowest neg log posterior so x=1.0 and y=1.7 are
taken as the solution values.
min x = 0.9, max x = 1.1
x fit error = sqrt{ (1.0-0.9)^2 + (1.0-1.1)^2 } = 0.141
min y = 1.7, max y = 2.2
y fit error = sqrt{ (1.7-1.8)^2 + (1.7-2.2)^2 } = 0.510

It is possible that the algorithm will fail to converge and exceed the 
maximum iterations limit i.e. the simplex has not shrunk down to the required 
tolerance. In this case the program will report the lack of sucessful 
convergence and attempt to supply errors etc as normal. This may well be 
acceptable - it is up to the user to look at and consider the size of
the minumum/maximum simplex bounds and errors reported.



Posterior, Goodness-of-fit
==========================

At the solution position the (unnormalised) negative log posterior is given 
(i.e. it is sum of the negative log prior and negative log likelihood without
the addition of the negative log evidence).
Also reported is the sum of sqaured deviations
between data and model points:
     sum of sqrd devs = sum { (data-model)^2 }
The chi sqaured value is also reported:
     chi sqrd = sum { ( (data-model)/(error in data) )^2 }
The number of degrees of freedom (vis + triple data points - no of free
parameters) is reported along with the chi sqrd value divided by this.



Errors
======

The hessian matrix Hes[ij] = (d^2/(dxi*dxj))(-log posterior) is computed
at the solution point. Hessian elements are estimated using a numerical
differentiation method:
1. for on-diagonal elements H[ii] = (d^2/dxi^2)(-log posterior) the element
   is estimated to be:
   H[ii] = { P(x+dx) + P(x-dx) - 2P(x) }/dx^2
   where x = x[i] dx = delta.x[i]

2. for off-diagonal elements H[ij] = (d^2/(dxi.dxj))(-log posterior) the
   element is estimated to be:
   H[ij] = {P(x+dx,y+dy)+P(x-dx,y-dy)-P(x+dx,y-dy)-P(x-dx,y+dy)}/{4.dx.dy}
   where x=x[i] y=x[j]

The covariance matrix Cov[ij] is the inverted Hes matrix. Some problems
appear to arise where diagonal elements of the matrix, corresponding to the
variances in the parameters, are negative. This could possibly point to 
poorly chosen priors or a poor fit/irregularities in the negative log posterior
surface. Where such negative values occur the program warns the user.

The correlation matrix Cor[ij] = Cov[ij] / sqrt { Var[i].Var[j] } is also 
computed. n.b. Var[i] is defined as Cov[ii]. Problems arise in the case
of negative elements on the Cov diagonals i.e. negative Var[i]'s - in this
case the correlation matrix will be incomplete with mathematically illegal
elements set to zero.

The "hessian-based error" of a parameter is the square root of the variance
in the quantity. 

The "total error" is taken to be the hessian-based error plus the "fit 
error" in the parameter. This implicity assumes that the curavture of the
negative log posterior is constant across the final simplex and so the error
in a parameter is based upon an uncertainty in the position of the minimum
(fit error) as well as the narrowness of the posterior peak (hessian error).







